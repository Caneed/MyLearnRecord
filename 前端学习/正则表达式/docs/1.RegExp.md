# 正则表达式

[TOC]

## 创建正则表达式

> 有三种创建正则表达式的方法：字面量创建；首个参数为字面量的构造函数创建；首个参数为字符串的构造函数创建。

```ts
const reg: RegExp = /ab+c/i
const reg1: RegExp = new RegExp('ab+c', 'i')
const reg2: RegExp = new RegExp(/ab+c/, 'i')
```

## 构造函数`constructor`

> RegExp()用于创建正则表达式对象，此对象用于将文本和模式进行匹配：

使用字面量，构造函数和工厂模式创建正则表达式对象：

```
/pattern/flags
new RegExp(pattern, [, flags])
RegExp(pattern, [, flags])
```

### 参数

- pattern:正则表达式的文本，ES5 之前正则表达式的构造函数只接受字符串作为文本参数，ES5 之后不仅接受字符串，而且接受字面量作为参数。
- flags:正则表达式的标志。

### Flags

flags 接受以下任何字符的组合（简单介绍）:

1. g(全局匹配)：找到所有符合条件的字符串，而不是找到第一个之后就停止。
2. i(忽略大小写)：匹配时忽略字符的大小写，如果和`u`搭配使用的话，就使用 Unicode 大小写折叠。
3. m(多行匹配)：开启多行匹配意味着将字符串中每一行的开头和结尾`\n或者\r分隔`
4. s(点号匹配所有字符):允许`.`匹配新的行。
5. u(Unicode):开启完整的 Unicode 支持。
6. y(“粘滞”模式):在文本你的确切位置搜索。

## 属性

### RegExp.prototype.dotAll

dotAll 属性表示是否使用了后缀修饰符`/s`，返回一个布尔值。

```ts
const reg: RegExp = new RegExp('abc')
console.log(reg.dotAll) //false
const reg1: RegExp = new RegExp('abc', 's')
console.log(reg1.dotAll) //true
```

### RegExp.prototype.flags

flags 属性返回当前正则表达式对象的修饰符

```ts
const reg: RegExp = new RegExp('abc', 's')
const reg1: RegExp = new RegExp('abc', 'gu')
const reg2: RegExp = new RegExp('abc')
console.log(reg.flags) //s
console.log(reg1.flags) //gu
console.log(reg2.flags) //不输出
```

### Regexp.prototype.global

global 作为正则表达式对象的只读属性，返回当前是否使用了`g`修饰符

```ts
const reg: RegExp = new RegExp('abc', 'g')
const reg1: RegExp = new RegExp('abc', 's')
console.log(reg.global) //true
console.log(reg1.global) //false
```
