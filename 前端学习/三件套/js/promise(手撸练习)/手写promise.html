<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    class myPromise {
      // 创建三种状态
      static PENDING = "pending";
      static FULFILLED = "fulfilled";
      static REJECTED = "rejected";
      constructor(func) {
        // 初始化状态
        this.promiseState = myPromise.PENDING;
        // 初始化值,初始值为null后面调用resolve或者reject时会改变它的值
        this.promiseResult = null;
        // 设置两个保存成功和失败回调结果的数组
        this.onFulfilledCallbacks=[]
        this.onRejectedCallbacks=[]
        // 加上bind(this)是在实例化时调用的resolve和reject的指向会改变，所以要强行绑定
        // 调用传入的func,也就是resolve和reject时要进行错误捕获，如果捕获到了就调用reject并把error传入
        try {
          // 捕获错误
          func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
          // 捕获到了直接reject
          this.reject(error)
        }
      }

      // resolve和reject
      resolve(result) {
        // 改变状态
        if (this.promiseState === myPromise.PENDING) {
          this.promiseState = myPromise.FULFILLED;
          // 给promise的结果赋值
          this.promiseResult = result;
          // 遍历成功的数组。如果有值则执行它的fulfilled
          this.onFulfilledCallbacks.forEach(callback=>{
            callback(result)
          })
        }
      }
      reject(reason) {
        if (this.promiseState === myPromise.PENDING) {
          this.promiseState = myPromise.REJECTED;
          this.promiseResult = reason;
          this.onRejectedCallbacks.forEach(callback=>{
            callback(reason)
          })
        }
      }

      // then方法
      // 参数是两个函数
      then(onFulfilled, onRejected) {
        // 如果此时的状态为pending的话，那么先暂存到数组中
        if(this.promiseState===myPromise.PENDING){
          // 添加到数组,要异步存储

          this.onFulfilledCallbacks.push(()=>{setTimeout(()=>{
            onFulfilled(this.promiseResult)
          })})
          this.onRejectedCallbacks.push(()=>{
            setTimeout(()=>{
              onRejected(this.promiseResult)
            })
          })
        }
        // 判断状态并选择调用函数，讲结果传入
        if(this.promiseState===myPromise.FULFILLED){
          // 实现异步的功能
          setTimeout(()=>{
            onFulfilled(this.promiseResult)
          })
        }
        if(this.promiseState===myPromise.REJECTED){
          setTimeout(()=>{
            onRejected(this.promiseResult)
          })
        }

      }
    }

    // 测试
    let p = new myPromise((resolve, reject) => {
      resolve("hello");
      // throw new Error('error')
      // reject('error')
    });
    p.then(res=>{
      console.log(res+1);
    },reason=>{
      console.log(reason);
    })
    p.then(res=>{
      console.log(res+2);
    })
    p.then(res=>{
      console.log(res+3);
    })

    // // 原生Promise
    // let p2 = new Promise((resolve, reject) => {
    //   // resolve("hello");
    //   reject('error')
    // });
    // p.then(res=>{
    //   console.log(res);
    // },reason=>{
    //   throw reason
    // })
    
  </script>
</html>
