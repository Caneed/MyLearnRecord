# symbol

[TOC]

### symbol
在ES5的时候变量的创建都是使用字符串，容易造成`属性名`的冲突，所以在ES6引入了JS的第七种数据类型`symbol`
`null,undefined,symbol,Number,Object,String,Boolean`.

### 使用

##### symbol的定义
symbol由`symbol`方法生成
```js
let s=symbol()
console.log(typeof s);//symbol
```
这样定义的s就是一个独一无二的值，它的类型为symbol而不是string或者其他类型
**symbol**不能使用关键字new，这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。


##### symbol接受参数
symbol函数可以允许接收一个字符串作为参数，表示对于symbol类型的描述。
```js
  let a=Symbol('hello')
  console.log(a)//Symbol(hello)
  console.log(a.toString())//"Symbol(hello)"
```

##### symbol将对象作为参数
Symbol方法同时允许对象作为参数，这样输出的symbol类型为([object Object])
```js
  let obj={
    b:12
  }
  let a=Symbol(obj)
  console.log(a)//Symbol([object Object])
```
**如果此对象中有toString()方法，那么symbol中传入的此对象会自动转换为toString()返回的值**
```js
  let obj2={
    toString(){
      return '123'
    }
  }
  let b=Symbol(obj2)
  console.log(b)//Symbol(123)
```
##### symbol之间的比较
两个symbol之间也不相等，即使传入的是相同的参数也不相等，因为symbol中传入的参数只是对他的描述
```js
  let a=Symbol('123')
  let b=Symbol('123')
  let c=Symbol()
  let d=Symbol()
  console.log(a==b)//false
  console.log(a===b)//false
  console.log(c==d)//false
  console.log(c===d)//false
```

##### symbol的转换和运算
symbol不能和其他类型的值进行运算，会报错。
但是symbol可以转换为boolean或者String类型的值,但是无法转换为Number
```js
  let a=123
  let b=Symbol('123')
  let c=Symbol()
  // console.log(a+b)//err
  console.log(b.toString(),String(b))//Symbol(123) Symbol(123)
  console.log(Boolean(b))//true
  console.log(Number(b))//err
```

##### Symbol.prototype.description
symbol中传入的参数作为symbol的描述，但是用`toString`或者`String`不能直接将描述打印
这时使用`Symbol.prototype.description`方法可以单独将描述打印
```js
  // Symbol.prototype.description
  let a=Symbol('123')
  console.log(a.description)//123
```

##### Symbol作为属性名
由于symbol的值都不相等，所以它可以用作标识符，用于对象的属性名。防止出现相同的属性名，这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。
**symbol作为属性名时，不可以使用.运算符**
**同样的，symbol作为属性名去被定义时也要使用[]来赋值**
```js
  // symbol作为属性名
  let a=Symbol('123')
  let obj={
    [a]:'hello'
  }
  console.log(obj.a)//undefined
  console.log(obj[a])//hello
```
**Tips:symbol作为属性名时，它是一个公有属性而不是私有**

##### 遍历有symbol类型成员的对象
Symbol作为属性名时，在对象遍历的时候symbol不会在`for in 或者 for of 也不会在Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify() `中遍历到。
```js
  let a=Symbol('123')
  let obj={
    b:'world',
    [a]:'hello',
    c:'damn'
  }
  for(i in obj){
    console.log(i,obj[i])//b world c damn
  }
  console.log(JSON.stringify(obj))//{"b":"world","c":"damn"}
  console.log(Object.keys(obj))//['b', 'c']
  console.log(Object.getOwnPropertyNames(obj))//['b', 'c']
```
这时需要使用`Object.getOwnPropertySymbols()`方法来得到symbol类型的属性
```js
 console.log(Object.getOwnPropertySymbols(obj))//[Symbol(123)]
```
还有一个API`Reflect.ownKeys()`方法可以返回所有对象的键名，包括symbol类型
```js
  console.log(Reflect.ownKeys(obj))//['b', 'c', Symbol(123)]
```
由于symbol在对象中具有此类特性，所以有时需要定义一个非私有的，但是又只希望用于内部的方法，就可以使用symbol

##### `Symbol.for,Symbol.keyFor`
有时，我们希望重新使用同一个 Symbol 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。
```js
  let s1=Symbol.for('123')
  let s2=Symbol.for('123')
  console.log(s1==s2)//true
  console.log(s1===s2)//true
```
Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。

**`Symbol.keyFor()`**用于返回一个已经全局注册过的symbol类型
```js
  let a=Symbol('123')
  console.log(Symbol.keyFor(s1))///123
  console.log(Symbol.keyFor(a))//undefined
```