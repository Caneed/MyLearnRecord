# 面向对象

[TOC]

### 类

TS 中的类和 ES6 的类一样(略)

### 抽象类

抽象类:在 class 关键字前加上 abstract 来表示某个抽象类，抽象类不能被实例化，它就是用来被继承的

抽象方法：在方法前加上`abstract`关键字来表示某个抽象方法，抽象方法不写函数体，继承该抽象类的类都需要重写此抽象方法

```ts
abstract class Animal {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  // 抽象方法
  abstract sayHello(): void;
}

class Dog extends Animal {
  name;
  age;
  constructor(name: string, age: number) {
    super(name, age);
  }
  sayHello() {
    console.log("hello");
  }
}

const dog = new Dog("旺财", 11);
dog.sayHello();
```

### 接口

接口指的是定义一个类的结构，而不去考虑它的实质的值，在接口中所有方法都是抽象方法

```ts
interface myInterface {
  name: string;
  age: number;
  sayHello(): void;
}
```

使用类去实现接口时使用`implements`来进行接口的实现

```ts
class Dog implements myInterface {
  name;
  age;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  sayHello() {
    console.log("wowowowo");
  }
}
```

### 属性的封装

ts 中在属性前加上修饰符
public:公共的属性.可以在任意位置修改(也是默认值)
private:私有属性，只能在类内部进行修改，通过方法使得外部可以访问到内部的私有属性`getter和setter`
protect:保护属性，可以在当前类或者是当前类的子类去访问，外部不能访问

```ts
class Person {
  private name: string;
  public age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  // 普通函数的设置方式
  getName() {
    return this.name;
  }
  setName(name: string) {
    this.name = name;
  }
}
```

ts 中专门设置了 getter 和 setter 方法

在外部访问属性的时候可以省略方法名，直接 .属性名 来访问

```ts
    get Name(){
      return this.name
    }
    set Name(value:string){
      this.name=value
    }
      // person.getName()
  person.Name
  person.Name='华为'
```

### 特殊写法

类的一种简写形式

```ts
class C {
  constructor(public name: string, public age: number) {}
}
const c = new C("123", 123);
```

### 泛型

定义函数或者类时，如果类型不明确，就需要泛型

```ts
function fn<T>(a: T): T {
  return a;
}

fn(10);
fn<string>("hello");
```

T 就是指任意类型，在调用时再明确这个类型是什么类型

也可以指定多个类型

```ts
function fn2<T, K>(a: T, b: K): K {
  console.log(a);
  return b;
}
fn2(10, "hello");
fn2<number, string>(10, "hello");
```
 