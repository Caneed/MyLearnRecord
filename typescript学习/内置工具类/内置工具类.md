# 内置工具类

[TOC]

> TS 内置了许多工具类：

## Awaited<Type>

Awaited<T> 的功能和 await 或者是 promise.then()的功能很像，它的用处主要是递归解包 Promise:

```ts
type A = Awaited<Promise<Promise<Promise<number>>>>
// type A = number
```

手动使用`infer`和条件类型可以实现：

```ts
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T

type B = MyAwaited<Promise<Promise<Promise<number>>>>
// type B = number
```

## Partial<Type>

Partial<T>将泛型类型中的属性变成可选属性：

```ts
type A = Partial<{
  name: string
  age: number
}>

// type A = {
//     name?: string | undefined;
//     age?: number | undefined;
// }
```

手动实现：

```ts
type MyPartial<T> = { [Property in keyof T]?: T[Property] | undefined }

type B = MyPartial<{
  name: string
  age: number
}>
```

## Required<Type>

和 Partial<T>相反，它将属性变成必选属性

```ts
type A = Required<{
  name?: string
  age?: number
}>
// type A = {
//     name: string;
//     age: number;
// }
```

手动实现：

```ts
type MyRequired<T> = {
  [P in keyof T]-?: T[P]
}

type B = MyRequired<{
  name?: string
  age?: number
}>

// type B = {
//     name: string;
//     age: number;
// }
```

## Readonly<Type>

将所有属性变为 readonly 修饰符的属性：

```ts
type A = Readonly<{
  name: string
  age: number
}>
// type A = {
//     readonly name: string;
//     readonly age: number;
// }
```

手动实现：

```ts
type MyReadonly<T> = {
  +readonly [P in keyof T]: T[P]
}

type B = MyReadonly<{
  name: string
  age: number
}>
// type B = {
//     readonly name: string;
//     readonly age: number;
// }
```

## Record<Keys,Type>

构造一个对象类型，泛型传入的第一个类型作为对象类型的属性名， 传入的第二个类型作为对象类型的值，可用于将一种类型的属性映射到另一种类型。
**其中第一个参数类型约束为 string|number|symbol**

```ts
type Person = {
  age: number
  grade: '1' | '2' | '3'
}

type Names = 'Mick' | 'John' | 'Amy'

type Students = Record<Names, Person>

// type Students = {
//     Mick: Person;
//     John: Person;
//     Amy: Person;
// }
```

手动实现：

```ts
type MyRecord<K extends string | number | symbol, V> = {
  [P in K]: V
}

type MyStu = MyRecord<Names, Person>
// type MyStu = {
//     Mick: Person;
//     John: Person;
//     Amy: Person;
// }
```

## Pick<Type,keys>

Pick<T,keys>从类型中选出几组属性组成新的类型：

```ts
type Todo = {
  drink: boolean
  eat: boolean
  sleep: boolean
  work: boolean
  play: boolean
}

type done = Pick<Todo, 'drink' | 'eat' | 'sleep'>
// type done = {
//     drink: boolean;
//     eat: boolean;
//     sleep: boolean;
// }
```

手动实现：

```ts
type MyPick<K, V extends keyof K> = {
  [P in V]: K[P]
}

type MyDone = MyPick<Todo, 'drink' | 'eat' | 'sleep'>
// type MyDone = {
//     drink: boolean;
//     eat: boolean;
//     sleep: boolean;
// }
```
