# 条件类型

[TOC]

类型的定义也可以使用条件进行判断

```typescript
interface Animal {}
interface Dog extends Animal {}
interface Cat extends StreamPipeOptions {}

type Equal = Dog extends Animal ? string : boolean
type Unequal = Cat extends Animal ? string : boolean
```

条件类型可以和泛型一起使用：

```typescript
interface IdLabel {
  id: number
}

interface NameLabel {
  name: string
}

type getLabel<T extends number | string> = T extends number
  ? IdLabel
  : NameLabel

function createLabel<T extends number | string>(label: T): getLabel<T> {
  return 'unimplemented'
}

console.log(createLabel('aaa'))
console.log(createLabel(123))
```

> 这里方法的参数传入的如果是 number 类型。那么泛型 T 就返回 number 类型，同时 getLabel 类型接收到 number 类型之后进行判断，T 如果继承了 number 类型，就返回 IdLabel 类型，否则返回 NameLabel 类型

## 条件类型约束

在想要获取泛型中的某个属性类型并赋值给另外一个属性时:

```typescript
type getMessageType<T> = T['message'] //类型“"message"”无法用于索引类型“T”。
```

因为泛型 T 上不存在属性 message

此时可以加上约束条件：

```typescript
type getMessageType<T extends { message: unknown }> = T['message']

interface strMessage {
  message: string
}

type MessageType = getMessageType<strMessage>
```

可以在泛型定义时给泛型进行条件约束，让泛型继承一个带有 message 属性的类型，此时泛型的传值就有了约束，如果传入一个没有 message 属性的类型进行泛型的占位会报错：

```ts
interface NoMessage {
  name: string
}
type ErrorType = getMessageType<NoMessage>
//类型“NoMessage”不满足约束“{ message: unknown; }”。
// 类型 "NoMessage" 中缺少属性 "message"，但类型 "{ message: unknown; }" 中需要该属性。ts(2344)
```

**条件类型约束也可以和之前的条件类型进行结合，之前的代码中泛型类型被约束后，只能接收一个具有 message 属性的类型，如果配合上条件类型就可以进行判断：**

```ts
type getMessageType<T> = T extends { message: unknown } ? T['message'] : boolean

interface strMessage {
  message: string
}

interface NoMessage {
  name: string
}

type MessageType = getMessageType<strMessage> //type = string
type NoMessageType = getMessageType<NoMessage> //type = boolean
```

> 将条件约束和条件判断类型做了结合，如果泛型 T 含有 message 属性就返回 message 属性的类型，否则就返回布尔类型

```typescript
type Flatten<T> = T extends any[] ? T[number] : T

type str = Flatten<number>
type arr = Flatten<string[]>
```

flatten 类型判断泛型是否时数组类型，如果是数组类型就返回数组成员的类型，如果不是就返回泛型本身
相当于:

```ts
type str = number
type arr = string
```

## 条件类型推断

条件类型提供了关键字`infer`

```typescript
type Flatten<T> = T extends Array<infer Item> ? Item : T

```
