<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
</body>
<script>
  // 声明构造函数来覆盖原生promise
  function Promise(executor){
    // 声明状态和结果值
    // 初始的状态和结果值分别为pending和空
    this.promiseState='pending',
    this.promiseResult=null
    // 保存实例对象上this的值
    const _this=this

    // 声明一个callback用来存放异步函数中调用的回调函数
    const callback={}
    // 声明resolve
    function resolve(value){
      // promise的状态只能更改一次，如果状态不是pending则直接返回
      if(_this.promiseState!=='pending') return;
      // 修改状态(promiseState)和结果值(promiseResult)
      _this.promiseState='resolved'
      _this.promiseResult=value

      // 异步操作执行完之后,再进行调用回调
      if(_this.callback.onResolved){
        _this.callback.onResolved(value)
      }
    }

    // 声明reject
    function reject(reason){
      // promise的状态只能更改一次，如果状态不是pending则直接返回
      if(_this.promiseState!=='pending') return;
      // 修改状态(promiseState)和结果值(promiseResult)
      _this.promiseState='rejected'
      _this.promiseResult=reason

          // 异步操作执行完之后,再进行调用回调
          if(_this.callback.onRejected){
        _this.callback.onRejected(reason)
      }
    }

    // 通过try catch来进行catch()方法的封装
    try {
          // 同步调用执行器函数
          // try方法捕获到了异常并将异常结果传到catch(e)中
    executor(resolve,reject)
    } catch (e) {
      // 在catch捕获到异常时，调用reject并将异常传入reject()方法
      reject(e)
    }
  }

  // then()方法的添加
  Promise.prototype.then=function(onResolved,onRejected){
    // 根据条件来指定回调
    if(this.promiseState==='resolved'){
      // 指定回调并将结果传入
      onResolved(this.promiseResult)
    }
    if(this.promiseState==='rejected'){
      // 指定回调并将结果传入
      onRejected(this.promiseResult)
    }
    // 在异步执行promise时因为状态没有发生改变所以无法指定上面的两个回调，所以要在状态为pending时进行判断
    if(this.promiseState==='pending'){
      // 将两个回调函数保存到实例对象上，在异步操作结束之后再执行
      this.callback={
        onRejected:onRejected,
        onResolved:onResolved
      }
    }

  }


  // 测试
  let p=new Promise((resolve,reject)=>{
    setTimeout(()=>{
      resolve('ok')
    },1000)

  })
  p.then(value=>{
    console.log(value)
  },reason=>{
    console.log(reason)
  })
</script>
</html>