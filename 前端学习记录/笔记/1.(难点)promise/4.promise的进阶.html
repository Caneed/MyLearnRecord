<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    // 改变promise对象的状态的方法
    // let p=new Promise((resolve,reject)=>{
    //   // // 第一种,调用resolve函数
    //   // resolve('ok')//pending->fulfilled
    //   // // 第二种,调用rejected函数
    //   // reject('err')//pending->rejected
    //   // 第三种,抛出错误
    //   throw 'err'
    // })

    // // promise指定多个成功或者失败的回调函数
    // let p = new Promise((resolve, reject) => {
    //   resolve("ok");
    // });
    // // 指定回调
    // p.then((value) => {
    //   console.log(value);
    // });
    // p.then((value) => {
    //   console.log(value);
    // });
    // p.then(
    //   (value) => {},
    //   (reason) => {
    //     console.log(reason); //不会输出
    //   }
    // );
    // // ok ok

    // promise改变状态和指定回调函数的执行顺序
    // // 一般情况
    // let p=new Promise((resolve,reject)=>{
    //   resolve('ok')
    // })
    // p.then(value=>{
    //   console.log(value)
    // },reason=>{
    //   console.log(reason)
    // })//ok

    // 构造器中调用的是一个异步
    // let p=new Promise((resolve,reject)=>{
    //   setTimeout(()=>{
    //     resolve('ok')
    //   },1000)
    // })
    // p.then(value=>{
    //   console.log(value)
    // },reason=>{
    //   console.log(reason);
    // })

    // // 异步情况下后调用then
    // let p=new Promise((resolve,reject)=>{
    //   setTimeout(()=>{
    //     resolve('ok')
    //   },1000)
    // })
    // setTimeout(()=>{
    //   p.then(value=>{
    //   console.log(value)
    // },reason=>{
    //   console.log(reason);
    // })
    // },2000)

    // let p = new Promise((resolve, reject) => {
    //   resolve("ok");
    // });
    // let res = p.then(
    //   (value) => {
    //     // 1.返回异常
    //     throw "err";
    //     // [[PromiseState]]: "rejected"
    //     // [[PromiseResult]]: "err"

    //     // 2.返回非promise的值
    //     return 1123;
    //     // [[PromiseState]]: "fulfilled"
    //     // [[PromiseResult]]: 1123

    //     // 3.返回一个promise对象
    //     return new Promise((resolve, reject) => {
    //       // //返回的是失败
    //       // reject();
    //       // // [[PromiseState]]: "rejected"
    //       // // [[PromiseResult]]: undefined

    //       // // 返回的是成功
    //       // resolve();
    //       // // [[PromiseState]]: "fulfilled"
    //       // // [[PromiseResult]]: undefined
    //     });
    //   },
    //   (reason) => {
    //     console.log(reason);
    //   }
    // );

    // console.log(res);


    // let p=new Promise((resolve,reject)=>{
    //   resolve()
    // })
    // p.then(value=>{
    //   console.log(this)
    // },reason=>{
    //   console.log(reason)
    // }) 


    // // then()方法的链式使用
    // let p=new Promise((resolve,reject)=>{
    //   resolve('ok')
    // })
    // p.then(value=>{
    //   return new Promise((resolve,reject)=>{
    //     resolve('success')
    //   })
    // }).then(value=>{
    //   console.log(value)
    // })
    // //success

    // // then()方法的异常穿透
    // let p=new Promise((resolve,reject)=>{
    //   resolve('ok')
    //   // reject('err')
    // })
    // p.then(value=>{
    //   console.log(111)
    // }).then(value=>{
    //   throw 'err'
    // }).then(value=>{
    //   console.log(333)
    // }).catch(reason=>{
    //   console.log(reason)
    // })
    // // 成功时执行的结果为111,222,333
    // // 失败时的结果为err


    // // then()方法链式调用的中断
    
    // // then()方法的异常穿透
    // let p=new Promise((resolve,reject)=>{
    //   resolve('ok')
    // })
    // p.then(value=>{
    //   console.log(111)
    //   return new Promise(()=>{})
    // }).then(value=>{
    //   throw 'err'
    // }).then(value=>{
    //   console.log(333)
    // }).catch(reason=>{
    //   console.log(reason)
    // })
    // //111

    let p=new Promise((resolve,reject)=>{
      setTimeout(()=>{
        throw 'err'
      },1000)
    })
    console.log(p)
  </script>
</html>
