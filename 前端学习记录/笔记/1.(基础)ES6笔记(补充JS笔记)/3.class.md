# class

[TOC]

### class 类的语法

ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

##### 类的实现

```js
class Car {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
```

ES6 的类可以看作是构造函数的另一种写法

##### 类的本质

```js
console.log(Car === Car.prototype.constructor); //true
console.log(typeof Car); //function
```

类的数据类型就是函数，类本身就指向构造函数。

使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致。

```js
class Car {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  run() {
    console.log("run");
  }
}
let a = new Car();
a.run(); //run
```

**类的所有方法都定义在构造函数的原型上面**

```js
class Car(){
  constructor(){}
  run(){}
  beep(){}
}
// 相当于
Car.prototype={
   constructor(){},
  run(){},
  beep(){}
}
```

所以在类的实例上调用方法，实际上是在调用原型的方法
**由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。 Object.assign 方法可以很方便地一次向类添加多个方法。**

```js
Object.assign(Car.prototype, {
  beep() {
    console.log("beep");
  },
  transform() {
    console.log("汽车人，变形");
  },
});
let b = new Car();
b.beep(); //beep
b.transform(); //汽车人，变形
```

类的内部定义的方法是不可以枚举的

```js
console.log(Object.keys(Car)); //[]
```

**但是使用 ES5 的方法来创建类，其中类内部的方法就是可以枚举的**

```js
let Truck = {
  crack() {},
  beep() {},
  run() {},
};
console.log(Object.keys(Truck)); //['crack', 'beep', 'run']
```

##### constructor 方法

constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。

```js
class Car {
  constructor() {
    console.log("aaa");
  }
}
// 构造函数自动被调用
let a = new Car(); //aaa

class Truck {
  // 没有定义构造函数
}
let b = new Truck();
// 没有定义构造函数的话会默认添加一个空的构造
console.log(b.__proto__); //{constructor: ƒ}
```

构造函数默认返回的是创建的实例

```js
class Truck {
  // 没有定义构造函数
}
let b = new Truck();
console.log(b instanceof Truck); //true
```

如果构造函数返回一个全新的对象，那么就会造成此实例对象不属于该类的实例了

```js
class Truck {
  // 没有定义构造函数
}
class Plane {
  constructor() {
    return new Truck();
  }
}
let c = new Plane();
console.log(c instanceof Plane); //false
console.log(c instanceof Truck); //true
```

这里的 plane 类中的构造函数返回的是 truck 类，所以创建的实例 c 属于 truck 的实例

##### 实例

实例的属性除非显式定义(this 关键字)在它的本身，不然的话都是定义在原型上的

```js
class Car {
  constructor(a, b) {
    this.a = a;
    this.b = b;
    this.beep = function () {};
  }
  run() {
    console.log("run");
  }
}

let c = new Car(2, 3);
console.log(c.hasOwnProperty("a")); //true
console.log(c.hasOwnProperty("b")); //true
console.log(c.hasOwnProperty("beep")); //true
console.log(c.hasOwnProperty("run")); //false
console.log(c.__proto__.hasOwnProperty("run")); //true
console.log(JSON.stringify(c)); //{"a":2,"b":3}
```

由于类中的 run()方法定义在 Car 类上，所以它是原型对象的属性。这个特性和 ES5 保持一致
同时 ES5 和 ES6 的类中都共享一个原型对象

```js
console.log(c.__proto__ === d.__proto__); //true
```

##### **proto**和 prototype

在类中添加方法相当于在类的原型对象上添加方法

```js
class Car {}

let a = new Car();
let b = new Car();
a.__proto__.run = function () {
  console.log("run");
};
a.run(); //run
b.run(); //run

Car.prototype.beep = function () {
  console.log("beep");
};
a.beep(); //beep
b.beep(); //beep
```

可以使用 Object.getPrototypeOf(obj)来创建一个和实例的原型对象同名的变量，这个变量就是原型对象，也可以通过它来创建方法和变量

```js
let pro = Object.getPrototypeOf(b);
console.log(pro === Car.prototype); //true
console.log(pro === b.__proto__); //true
pro.beep(); //beep
pro.turn = function () {
  console.log("turn");
};
a.turn(); //turn
b.turn(); //turn
```

但是这种做法是不提倡的，因为在原型对象上添加方法之后所有的实例都可以使用此方法，所以尽量避免此类做法。

##### getter 和 setter

类的内部可以使用 getter 和 setter 函数，来对变量进行取值和赋值的操作

```js
class Car {
  constructor() {}
  a;
  get prop() {
    return this.a;
  }
  set prop(a) {
    this.a = a;
  }
}
let car = new Car();
car.prop = 3; //自动调用getter
console.log(car.prop); //3
```

存值和取值的函数都是设置在属性的 Descriptor 对象上的,在实例对象上无法访问 getter 和 setter

```js
console.log(Object.getOwnPropertyNames(car)); //['a']
```

使用 descriptor 可以访问到 getter 和 setter

```js
console.log(Object.getOwnPropertyNames(car)); //['a']
let descriptor = Object.getOwnPropertyDescriptor(Car.prototype, "prop");
console.log(descriptor); //{enumerable: false, configurable: true, get: ƒ, set: ƒ}
```

其中第一个参数为类的原型，第二个参数是 getter 和 setter 要设置和得到的属性值

##### 类的属性名

类的属性名可以使用表达式来设置

```js
// 类的属性名
let a = "beep";
class Car {
  constructor() {}
  [a]() {
    console.log("aaa");
  }
}
let car = new Car();
car.beep(); //aaa
```

定义一个变量 a 值为`beep`,然后在类中使用`[argv](){}`的方式来定义方法，其中方法名就是变量的值。

##### 类表达式

类可以用表达式的形式来定义

```js
const myClass = class Mine {
  getClassName() {
    return Mine.name;
  }
};
```

在类的内部可以使用 class 后的类名 Mine 表示类的内部使用，但是在外部使用这个类的话只能使用承接这个类的变量`myClass`

```js
let a = new myClass();
let b = new Mine(); //Mine is not defined
console.log(a.getClassName()); //Mine
```
如果类的内部没有用到它的话就可以省略
```js
const myClass=class{....}
```
