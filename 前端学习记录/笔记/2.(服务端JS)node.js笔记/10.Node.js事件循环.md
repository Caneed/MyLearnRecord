# 事件循环



[TOC]

### 事件循环

```
JS
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  bar()
  baz()
}

foo()
```

执行的顺序为:foo bar baz

整个调用堆栈的过程:

foo() => foo()  log('foo') => foo() => foo() bar() => foo() bar() log('bar') =>foo() bar() => foo() => foo() baz() => foo() baz() log('baz') => foo() baz() =>foo() => empty

每次事件循环的迭代过程中都要查看在调用堆栈中是否有东西并将它执行，采取的是先进后出的方式。

### 入队函数执行

`setTimeout(() => {}, 0)` 的用例是调用一个函数，但是是在代码中的每个其他函数已被执行之后。

或者`setInterval()`也有相同的性质

```JS
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  baz()
}

foo()

```

打印的结果为:foo baz bar

调用堆栈的顺序：

foo() => foo() log('foo') => foo() => foo() baz() => foo() baz() log('baz') => foo() baz() => foo() => bar() => bar() log('bar') => bar() 

=> empty

### 消息队列

当调用`setTimeout()`或者`setInterval()`时，浏览器或者node.js会调用定时器，当定时器结束(计时结束)后，会将`setTimeout()`中的回调函数放入消息队列。

在消息队列中，用户触发的事件（如单击或键盘事件、或获取响应）也会在此排队，然后代码才有机会对其作出反应。 类似 `onLoad` 这样的 DOM 事件也如此。

JS中的事件循环会优先执行调用栈堆中的任务，它会首先将调用栈堆中的东西处理，处理完了之后才会去消息队列中处理任务。

### ES6作业队列

ECMAScript 2015 引入了作业队列的概念，Promise 使用了该队列（也在 ES6/ES2015 中引入）。 这种方式会尽快地执行异步函数的结果，而不是放在调用堆栈的末尾。

在当前函数结束之前 resolve 的 Promise 会在当前函数之后被立即执行。

```JS
const bar = () => console.log('bar')

const baz = () => console.log('baz')

const foo = () => {
  console.log('foo')
  setTimeout(bar, 0)
  new Promise((resolve, reject) =>
    resolve('应该在 baz 之后、bar 之前')
  ).then(resolve => console.log(resolve))
  baz()
}

foo()
```

输出的顺序为：foo baz resolve bar