# JS刷题



[TOC]

### 此程序用于输出字符串中出现最多的字符

```
var str = 'acdaecad';
var obj = {};
for (var i = 0;i<str.length;i++){
            if (obj[str.charAt(i)]){ //判断是obj里是否有str里面某个字母的属性
                obj[str.charAt(i)]++;//如果有，给那个属性++
            }
            else {
                obj[str.charAt(i)] = 1;      //如果没有，给obj添加那个属性
        }
        }
var val1;
var val2 = 0;
for (var k in obj) { //for in 循环遍历对象，k是键（也就是对象的属性名) obj就是原对象
            if (obj[k] > val2){  如果obj的属性值大于val2    里面a出现的最多。++次数最多，也就是3
                val2 = obj[k];   //val2等于obj的属性值 
                val1 = k;  //最后将属性名赋予  
            }
}
console.log(val1);所以最后输出a
```

**解析：**首先定义了一个字符串`str`和一个对象`obj`之后进入循环，循环的次数是字符串的长度，第一个判断`obj[str.charAt(i)]`指判断`obj`中是否有`str`的某个字符的属性,如果有的话给这个属性`++`如果没有则添加此属性，并赋值为1。然后又一个循环，在`obj`中循环，如果`obj`中属性值(字符串中出现的次数)大于判断条件`val2`（初始值为0）的话，就让`val2`等于此属性值(记录当前最大的属性值)，然后将属性名赋予`val1`然后执行下一次循环，这样可以找到数值最大的属性，也就是在字符串中出现最多的属性



****



### 数组的排序

##### **冒泡排序**：

```
for (var i = 0;i<arr.length-1;i++){
    for (var j = 0;j < arr.length-1-i;j++){
        if(arr[j]>arr[j+1]){
            var temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}

console.log(arr);
```

##### **选择排序：**

```
var minIndex;
var temp;
for(let i = 1; i < arr.length; i++) {
    minIndex = i - 1;
    for(let j = i; j <arr.length; j++) {
        if(arr[j] < arr[minIndex]) minIndex = j;
    }
    if(minIndex != i-1) {
        temp = arr[i-1];
        arr[i-1] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
console.log(arr);
```

##### **插入排序：**

```
for(let i = 1; i < arr.length; i ++) {
    for(let j = i - 1; j>=0 && arr[j] > arr[j+1]; j --) {
        let temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
    }
}
console.log(arr);
```

##### **数组自身的sort()方法:**

```
arr.sort((a,b)=>b-a);
console.log(arr);
```

其中`b-a`是降序排列`a-b`为升序排列

### 关于get和set方法

下面程序的输出为抛出异常

```
class Phone{
  constructor(price){
    this.price = price;
  }
  get price(){
    return 999;
  }
}
var p = new Phone(888);
console.log(p.price);
//Uncaught TypeError: Cannot set property price of #<Phone> which has only a getter
```

如果类中只有`get`方法但是没有`set`方法，那么默认这个类中的属性为只读，这时如果强行改变这个属性就会抛出异常

解决方法：

1.不要在`constructor`中设置值.

2.给类中添加一个`set()`方法

```
    class Phone {
      constructor() {
      }
      get price() {
        return 999;
      }
    }
    var p = new Phone(888);
    console.log(p.price);//999
```

```
    class Phone {
      constructor() {
      }
      get price() {
        return 999;
      }
      set price(item){
        this.price=item
      }
    }
    var p = new Phone(888);
    console.log(p.price);//999
```

### 匿名函数的全局性

输出结果：

```
    var uname = "window";
    var object = {
      uname: "object",
      fun: function () {
        console.log(this.uname);
        return function () {
          console.log(this.uname);
        };
      },
    };
    object.fun()();
```

输出object,window。

**object.fun()()等效于var fn = object.fun(); fn();实际上是调用函数两次，第一次是调用object对象的fun函数，第二次是调用fun函数的返回函数。第一次调用fun函数时，this指向上一级对象，即object对象，因此输出对象object的uname属性值object,第二次调用的返回函数

### JS中0为分母

```
var num = prompt('请输入分母:')
try{
  console.log('a');
  value = 0 / num;
  console.log('b');
}
catch(e){
  console.log('c');
}
finally{
  console.log('d');
}
```

最终输出为a,b,d。

在JavaScript中0是可以作为分母的，0/0的结果为`NaN`,所以不会捕获异常，最后的输出就为a,b,d。

### 预处理

```
var a = 1;
function test() {
    console.log(a);
    if(false) {
        var a = 2;
    }
}
test();
```

最后的输出为`undefined`,虽然if中的语句没有执行，但是在预处理阶段还是会将if语句中的变量声明提升，上面的代码转换一下和下面的效果一样：

```
var a=1
function test(){
var a
console.log(a)
if(false){
a=2
}
}
```

### this绑定

```
var obj = {};
obj.log = console.log;
obj.log.call(console,this);
```

最后的输出为`window`

这道题看似在考this的绑定问题，实际上是通过this绑定为幌子，考察非严格模式下JavaScript语句中“this”默认指向全局对象（window）。

题目的关键点在第3行，我们知道，this绑定的优先级是new>bind>call(apply)>obj.func()>默认绑定。也就是说obj.log.call(console, this)语句中，实际上log函数内的this实际上指代的是console（这也是本题最大的陷阱！）。然而实际上这一语句中obj.log.call(console, this)这一语句中打印的this是在外部传进去的，和函数内的this对象根本没有关系！也就是说此时log函数内的this指代console，但是打印的是从外面传进去的this对象，也就是window！
